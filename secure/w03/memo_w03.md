・ストリーム暗号(streamcipher)　リアルタイムに強い

  ー送信者と受信者が同じ疑似乱数生成アルゴリズム、初期値、共通鍵を持ち、それで生成した乱数をデータにXOR演算（排他的論理和）する方式。教科書の図②.①参照。

    (乱数がばれたら破られる、疑似乱数生成アルゴリズムの複雑さが大事)

  ー送信者は平文に疑似乱数をXORして暗号化し、受信者はその暗号文に同じ疑似乱数をXORして復号する。

  ー暗号文のエラーは復号時に拡大しない。(後ろは壊れない　おぼえなくていいらしい)

  ーこの暗号の安全性は乱数の安全性に依存し、乱数に偏りが無く、周期が長いことが必要。(c言語のrand()は質が悪いらしい笑　偏りとかあるらしいから気軽に使ってはいけない。)

・ブロック暗号(blockciphen)

  ー平文を64ビットや128ビットなどのブロック単位に分割して、ブロックごとに暗号化を行う共通鍵暗号。(1bit単位で処理するらしい　換え字などの転置などのアイデアが使われている)

  -鍵スケジュール部とデータかくはん部で構成される。教科書の図②.③参照。



  ECBモード：普通　シンプルだけど弱点がある　並列化しやすいのもメリット
    ーブロックごとに独立して暗号化/復号を行う、基本かつシンプルなモード。

    -基本的な暗号そのものであるため、ElectronicCodeBook(暗号帳)方式と呼ぶ。

    ー複数の平文ブロックの内容が同じであれば、それらの暗号文ブロックも等しくなり、内容を推測されやすくなる。

    ー暗号文ブロックの①ビットのエラー(通信の際のノイズなど)が復号によってその平文ブロック全体に広がってしまう(当たり前の現象、かくはん処理のため)。


  CBCモード：後ろにつながる　できれば使える
    初期値をXORするあとはn-1の平文をxorする。
    広く利用されている
    連鎖している
    初期値は送受信の双方で共通の値を使う、公開しても良いが毎回変更する必要がある。
    暗号ブロック連鎖方式のため、エラーが平文で拡大してしまう。

  CTRモード：数字を暗号化（乱数生成）
    初期値を暗号化する　→　データにXORする処理をカウンタの値を1ずつ増やしながら知りする。
    ストリーム暗号である
    疑似乱数を1バイトに切り詰めると1byte単位に暗号化するストリーム暗号になる
    疑似乱数のもとの初期値の選定には注意が必要 時間に関する者にすれば安全
    復号にも暗号化アルゴリズムを用いる！！
    2回XOR処理すると元のデータに戻る

  DES(Data encryption standard)
    鍵生成を逆順にする　効率化
    総当たりで破られる
    データかくはん部
    SBOXの処理
      　換え字式暗号と同じ考え方
    転置式暗号などの線型変換は危ない？何回足しても一回で復号できてしまうかも
    DES暗号は非線形である。　→　三段のトリプル～も有効である。
  
  Triple-DES
    暗号化　違うカギで復号化　また違うカギで暗号化
    遅い
  
  AES(advanced encryption standard)
    現在主流
    Triple-DESよりも高速で安全

  AES > triple-des > DES

  windows11pro とかは対応していない


・鍵スケジュール部
  -鍵をそのまま暗号化に用いると処理に偏りが発生したりブロックサイズに満たなかったりするため、鍵を元にデータ量を増やした副鍵(拡大鍵)を生成する。

・データかくはん部
  ー副鍵を使って①ブロック分の平文を暗号文に変換する。


